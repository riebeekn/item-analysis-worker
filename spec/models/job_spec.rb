require 'spec_helper'
require 'fileutils'
require './app/models/job'
require './app/services/settings'

describe Job do
  after { Job.destroy_all }

  describe "attributes" do
    before { @job = Job.new }
    subject { @job }

    it { should respond_to(:exam) }
  end

  describe ".get_next_job_to_process" do
    context "when no jobs are queued" do
      it "should return nil" do
        Job.get_next_job_to_process.should be_nil
      end
    end

    context "when no pending jobs are queued" do
      before { FactoryGirl.create(:job, status: 'anything but pending') }

      it "should return nil" do
        Job.get_next_job_to_process.should be_nil
      end
    end

    context "when pending jobs are queued" do
      before do
        @job1 = FactoryGirl.create(:job)
        @job2 = FactoryGirl.create(:job)
      end

      it "should not return nil" do
        Job.get_next_job_to_process.should_not be_nil
      end

      it "should return the first job and update the job's attributes" do
        job = Job.get_next_job_to_process
        
        job.should eq @job1
        job.status.should eq Job::PROCESSING
        job.worker.should eq "localhost"
        job.exam.should_not be_nil
        check_start_time(job)
      end

      it "should return the second job when called a second time" do
        Job.get_next_job_to_process
        Job.get_next_job_to_process.should eq @job2
      end
    end
  end

  describe ".finish_processing" do
    before do 
      @job = FactoryGirl.create(:job, status: Job::PROCESSING) 
      @job.data_file = "./data/my_input_file.csv"
      File.new "./tmp/my_input_file.pdf", "w"
      File.new "./tmp/my_input_file.stats", "w"
      File.new "./tmp/my_input_file.scatter.svg", "w"
      @job.finish_processing
    end
    after do 
      File.delete("./tmp/my_input_file.pdf") 
      File.delete("./tmp/my_input_file.stats")
      File.delete("./tmp/my_input_file.scatter.svg")
    end

    it "should set the status of the job to done" do
      @job.status.should eq Job::DONE
      check_stop_time(@job)
    end
  end

  describe ".set_summary_exam_info" do
    let(:job) { FactoryGirl.create(:job, status: Job::PROCESSING) }
    before do 
      @dir = "#{Settings.TMP_DIR}#{job.id}"
      Dir.mkdir @dir
      FileUtils.cp("./spec/test_data/ctt_data_small_for_unit_tests.scored.csv", "#{@dir}/#{job.id}.scored")
      job.data_file = "./data/#{job.id}.csv"
      job.exam = Exam.new
      job.set_summary_exam_info
    end
    after { FileUtils.rm_rf @dir }

    it "should set the examinee count" do
      job.exam.examinee_count.should eq 10
    end

    it "should set the question count" do
      job.exam.question_count.should eq 5
    end

    it "should set the mean" do
      job.exam.mean.should eq 7.2
    end

    it "should set the std_dev" do
      job.exam.std_dev.should eq 4.044749683231337
    end
  end

  describe ".run_item_analysis" do
    let(:scatter_file) { "#{Settings.TMP_DIR}ctt_data_small_for_unit_tests.scatter.svg" }
    before do 
      @job = FactoryGirl.create(:job, status: Job::PROCESSING, 
                      data_file: "./data/ctt_data_small_for_unit_tests.scored.csv")
      exam = Exam.new
      exam.question_count = 5
      @job.exam = exam
      @dir = "#{Settings.TMP_DIR}#{@job.id}"
      Dir.mkdir @dir
      FileUtils.cp("./spec/test_data/ctt_data_small_for_unit_tests.scored.csv", "#{@dir}/#{@job.id}.scored")
      @file = "#{@dir}/#{@job.id}.item_analysis"

      @job.run_item_analysis
    end
    after { FileUtils.rm_rf @dir }
    
    describe "return appropriate status value" do
      it "should return true if the job succeeds" do
        @job.run_item_analysis.should eq true
      end
    end

    describe "output generated by method" do
      it "should create the output file" do
        File.exists?(@file).should eq true
      end

      it "should generate the expected file contents" do
        lines = File.readlines(@file)
        lines.count.should eq 6
        lines[0].split.should eq ["\"\",\"Sample.SD\",\"Item.total\",\"Item.Tot.woi\",\"Difficulty\",\"Discrimination\",\"Item.Criterion\",\"Item.Reliab\",\"Item.Rel.woi\",\"Item.Validity\""]
        lines[1].split.should eq ["\"1\",0.316227766016838,0.498970132789166,0.322094130040439,0.1,0.333333333333333,NA,0.14969103983675,0.0966282390121316,NA"]
        lines[2].split.should eq ["\"2\",0.483045891539648,0.534522483824849,0.254823595718813,0.3,0.666666666666667,NA,0.244948974278318,0.116774841624228,NA"]
        lines[3].split.should eq ["\"3\",0.52704627669473,0.680413817439772,0.421075960533259,0.5,0.666666666666667,NA,0.340206908719886,0.21053798026663,NA"]
        lines[4].split.should eq ["\"4\",0.516397779494322,0.722222222222222,0.490098029409803,0.6,1,NA,0.353815185068681,0.240098019199512,NA"]
        lines[5].split.should eq ["\"5\",0.483045891539648,0.831479419283098,0.683130051063973,0.3,1,NA,0.381031737766272,0.313049516849971,NA"]
      end
    end
  end

  describe ".stop_processing_due_to_error" do
    before do 
      @job = FactoryGirl.create(:job, status: Job::PROCESSING) 
      @job.stop_processing_due_to_error("error occured")
    end

    it "should set the status to error" do
      @job.status.should eq Job::ERROR
    end

    it "should set the stop time" do
      check_stop_time(@job)
    end

    it "should set the message" do
      @job.message.should eq "error occured"
    end
  end

  describe "filenames" do
    before do 
      @job = Job.new 
      @job.id = 3
    end
    context "when there is no input file" do
      it "should return nil" do
        @job.item_analysis_filename.should be_nil
        @job.scatter_plot_filename.should be_nil
        @job.pdf_filename.should be_nil
        @job.scored_filename.should be_nil
        @job.distractor_analysis_filename.should be_nil
        @job.histogram_filename.should be_nil
        @job.expected_filename(3).should be_nil
        @job.data_file_to_process.should be_nil
        @job.key_file_to_process.should be_nil
      end
    end

    context "when there is a valid input file" do
      before do
        @job.data_file = './data/my_input_file.csv'
        @job.key_file = './data/my_key_file.txt'
      end

      it "should have a valid temp directory" do
        @job.temp_dir.should eq "#{Settings.TMP_DIR}#{@job.id}/"
      end
      
      it "should have a valid item analysis filename" do
        @job.item_analysis_filename.should eq "#{Settings.TMP_DIR}#{@job.id}/#{@job.id}.item_analysis"
      end

      it "should have a valid scatter plot filename" do
        @job.scatter_plot_filename.should eq "#{Settings.TMP_DIR}#{@job.id}/#{@job.id}.scatter.svg"
      end

      it "should have a valid pdf filename" do
        @job.pdf_filename.should eq "#{Settings.TMP_DIR}#{@job.id}/item_analysis_#{@job.id}.pdf"
      end

      it "should have a valid scored filename" do
        @job.scored_filename.should eq "#{Settings.TMP_DIR}#{@job.id}/#{@job.id}.scored"
      end

      it "should have a valid distractor analysis file" do
        @job.distractor_analysis_filename.should eq "#{Settings.TMP_DIR}#{@job.id}/#{@job.id}.distractor_analysis"
      end

      it "should have a valid histogram filename" do
        @job.histogram_filename.should eq "#{Settings.TMP_DIR}#{@job.id}/#{@job.id}.histogram.svg"
      end

      it "should have valid expected filenames" do
        @job.expected_filename(3).should eq "#{Settings.TMP_DIR}#{@job.id}/#{@job.id}.expected_3.svg"
      end

      it "should have a valid data file to process" do
        @job.data_file_to_process.should eq "./data/my_input_file.csv"
      end

      it "should have a valid key file to process" do
        @job.key_file_to_process.should eq "./data/my_key_file.txt"
      end
    end
  end

  private
    def check_start_time(job)
      job.job_start.year.should eq Time.now.utc.year
      job.job_start.month.should eq Time.now.utc.month
      job.job_start.day.should eq Time.now.utc.day
      job.job_start.hour.should eq Time.now.utc.hour
      job.job_start.min.should eq Time.now.utc.min
    end

    def check_stop_time(job)
      job.job_stop.year.should eq Time.now.utc.year
      job.job_stop.month.should eq Time.now.utc.month
      job.job_stop.day.should eq Time.now.utc.day
      job.job_stop.hour.should eq Time.now.utc.hour
      job.job_stop.min.should eq Time.now.utc.min
    end
end
